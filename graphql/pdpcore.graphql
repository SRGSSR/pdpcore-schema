schema {
  query: Query
}

"Indicates a Bean Validation constraint"
directive @constraint(format: String, max: BigInteger, maxFloat: BigDecimal, maxLength: Int, min: BigInteger, minFloat: BigDecimal, minLength: Int, pattern: String) repeatable on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @deprecated(reason: String) on FIELD_DEFINITION | ARGUMENT_DEFINITION | ENUM_VALUE | INPUT_FIELD_DEFINITION

"""
Marks the definition as experimental with an optional reason.
Experimental API must not be used for production use as it can change
or be removed at any time without notice.
"""
directive @experimental(reason: String) on QUERY | MUTATION | SUBSCRIPTION

"Directs the executor to include this field or fragment only when the `if` argument is true"
directive @include(
    "Included when true."
    if: Boolean!
  ) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT

"Directs the executor to skip this field or fragment when the `if` argument is true."
directive @skip(
    "Skipped when true."
    if: Boolean!
  ) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT

"Exposes a URL that specifies the behaviour of this scalar."
directive @specifiedBy(
    "The URL that specifies the behaviour of this scalar."
    url: String!
  ) on SCALAR

"An agent represents a person, team or department."
interface Agent {
  "The name of the agent."
  name: String!
}

"A CMS website article."
type Article {
  "In the context of the PDP, this field is used to indicate whether the data may be published publicly."
  confidentialityLevel: ConfidentialityLevel!
  "The full text of the article."
  content: ArticleContent
  "People, teams or departments who contributed to the article."
  contributors: [Agent]
  "The genres this article belongs to."
  genres: [Genre]
  "The PDP id of the article."
  id: String!
  "The images of the article."
  images: [Image]
  "This field indicates whether the article is longer or more extensive."
  isLongForm: Boolean
  "A line of newspaper type set above a title usually in a different typeface and intended to provoke interest in, editorialize about, or provide orientation for the matter in the copy heads. The kicker may be available in different languages."
  kicker: [Text]
  "A lead is a self-contained, brief, and meaningful description of an article. The lead may be available in different languages."
  lead: [Text]
  "The date and time (expressed as timestamp) at which the article was modified. (ISO-8601)"
  modifiedAt: DateTime
  "The source system publishing the metadata."
  provenance: Provenance!
  "Indicates if the website article has been published online."
  publicationStatus: PublicationStatus
  "The business unit or external organisation publishing the metadata."
  publisher: Publisher!
  "Other articles related to this article."
  relatedArticles: [Article]
  "The date and time (expressed as timestamp) at which the article was produced. (ISO-8601)"
  releasedAt: DateTime
  "The id of the article in the source system. It is unique in the source system, but not globally."
  sourceId: String!
  "The source URL from where the article can be accessed in raw format."
  sourceUrl: URL
  "The title or headline of the article. The title may be available in different languages."
  title: [Text]
  "The URL from where the article can be accessed."
  url: URL
}

"The text content of an article."
type ArticleContent {
  "The complete, unformatted text of the article. The text should not contain any HTML tags or similar."
  text: [String]!
}

"A page containing articles matching the query filters."
type ArticlePage {
  cursor: String
  edges: [Article]!
}

"The aspect ratio of an asset."
type AspectRatio {
  "The aspect ratio, e.g. 16:9 or 4:3."
  ratio: String!
}

"A channel is a linear and non-linear broadcast vector for episodes, such as SRF1, RTSUn or PlaySuisse."
type Channel {
  "In the context of the PDP, this field is used to indicate whether the data may be published publicly."
  confidentialityLevel: ConfidentialityLevel!
  "Specifies the distribution vector of a channel."
  distributionVector: DistributionVector
  "The PDP id of the channel."
  id: String!
  "Images associated with the channel."
  images: [Image]
  "The name of the channel."
  name: String
  "The source system publishing the metadata."
  provenance: Provenance!
  "The business unit or external organisation publishing the metadata."
  publisher: Publisher!
  "The id of the channel in the source system. It is unique in the source system, but not globally."
  sourceId: String!
}

"A page containing clips matching the query filters."
type ChannelPage {
  cursor: String
  edges: [Channel]!
}

"A content contains the raw data of a domain object from a source system."
type Content {
  "In the context of the PDP, this field is used to indicate whether the data may be published publicly."
  confidentialityLevel: ConfidentialityLevel!
  "The domain type of the content."
  domainType: DomainType!
  "The PDP id of the content."
  id: String!
  "The source system publishing the metadata."
  provenance: Provenance!
  "The business unit or external organisation publishing the metadata."
  publisher: Publisher!
  "The data of the content in source schema."
  sourceData: SourceData!
  "The id of the content in the source system. It is unique in the source system, but not globally."
  sourceId: String!
}

"A page containing contents matching the query filters."
type ContentPage {
  cursor: String
  edges: [Content]!
}

"A department describes an organizational unit in the form of a department that is responsible for the editorial creation process of an audiovisual object. An example of an organizational unit is \"Culture\" or \"Sports\"."
type Department implements Agent {
  "The name of the department."
  name: String!
}

"""
The genre is used to classify audiovisual objects depending on their 
content into subject areas such as "Culture", "Sports", "News" or "Economy".
"""
type Genre {
  "A general description of the genre."
  description: Text
  "The preferred lexical label for a genre, in a given language."
  name: Text!
}

"Describes visual material - such as logos, thumbnails or other visual elements - that belong to an asset."
type Image {
  "Copyright information"
  copyright: String
  "The title of the image in potentially different languages."
  title: [Text]
  "Rights and restrictions associated to the image."
  usage: String
  "The various sizes available"
  variants: [ImageVariant]
}

type ImageVariant {
  "The aspect ratio of the image, e.g. 16:9 or 4:3."
  aspectRatio: AspectRatio
  "The height of the image in pixels."
  height: Int
  "The URL of the image."
  url: URL!
  "The intended usage of the image variant. "
  usage: String
  "The width of the image in pixels."
  width: Int
}

"A person is a clearly identifiable human actor who is involved in the creation of an editorial object."
type Person implements Agent {
  "The full name of the person."
  name: String!
  "The role(s) the person takes in relation to the asset."
  roles: [Role]
}

"Describes how a show is planned to be published on a specific channel"
type Publication {
  "The brief descriptions of the show in potentially different languages."
  exclusions: [String]
  "The brief descriptions of the show in potentially different languages."
  schedules: [Schedule]
}

"Query root"
type Query {
  "Returns the article with the provided PDP id or null if it does not exist."
  article(
    "A PDP id of an article."
    id: String!
  ): Article
  """
  **Experimental, do not use in production!**
  This query might be changed or removed at any time without notice.
  
  Lists the available article genres.
  """
  articleGenres(
    """
    The returned list will contain only genres that match all filters. Only
    filters with values affect the result. If you don't want to filter at all, then 
    you can set this field to null.
    """
    filter: ArticleGenreFilterInput
  ): [Genre]! @experimental
  "Returns articles matching the filter criteria."
  articles(
    "The cursor of the previous page. Set to null to get the first page."
    after: String,
    """
    The returned page will contain only articles that match all filters. Only
    filters with values affect the result. If you don't want to filter at all, then 
    you can set this field to null.
    """
    filter: ArticleFilterInput,
    "The number of articles per page."
    first: Int! @constraint(max : 500) @constraint(min : 1),
    "Specifies the order in which the query returns matching articles."
    sort: [ArticleSortInput] = []
  ): ArticlePage!
  "Returns the channel with the provided PDP id or null if it does not exist."
  channel(
    "A PDP id of a channel."
    id: String!
  ): Channel
  "Returns channels matching the filter criteria."
  channels(
    "The cursor of the previous page. Set to null to get the first page."
    after: String,
    """
    The returned page will contain only channels that match all filters. Only
    filters with values affect the result. If you don't want to filter at all, then 
    you can set this field to null.
    """
    filter: ChannelFilterInput,
    "The channels of channels per page."
    first: Int! @constraint(max : 500) @constraint(min : 1)
  ): ChannelPage!
  "Returns the content with the provided PDP id or null if it does not exist."
  content(
    "A PDP id of a content."
    id: String!
  ): Content
  "Returns contents matching the filter criteria."
  contents(
    "The cursor of the previous page. Set to null to get the first page."
    after: String,
    """
    The returned page will contain only contents that match all filters. Only
    filters with values affect the result. If you don't want to filter at all, then 
    you can set this field to null.
    """
    filter: ContentFilterInput,
    "The number of contents per page."
    first: Int! @constraint(max : 500) @constraint(min : 1)
  ): ContentPage!
  """
  **Experimental, do not use in production!**
  This query might be changed or removed at any time without notice.
  
  Full text search for articles.
  """
  searchArticles(
    "The number of articles."
    first: Int = 10 @constraint(max : 500) @constraint(min : 1),
    "The language of the words used in the search query."
    language: TextSearchLanguage = none,
    "The search query."
    query: String!
  ): [Article]! @experimental
  "Returns the show with the provided PDP id or null if it does not exist."
  show(
    "A PDP id of a show."
    id: String!
  ): Show
  "Returns shows matching the filter criteria."
  shows(
    "The cursor of the previous page. Set to null to get the first page."
    after: String,
    """
    The returned page will contain only shows that match all filters. Only
    filters with values affect the result. If you don't want to filter at all, then 
    you can set this field to null.
    """
    filter: ShowFilterInput,
    "The number of shows per page."
    first: Int! @constraint(max : 500) @constraint(min : 1)
  ): ShowPage!
}

"A role of a person in the context of an asset."
type Role {
  "The type of the role, e.g. \"Producer\" or \"Editor\"."
  name: String!
}

"""
A schedule defines a repeating time period used to describe a regularly
occurring episode. With the provided metadata fields, you are able to define the
schedule. The section "Schema Concepts: Show Schedules" in the PDP API
documentation goes into more details and provides a few example schedules.
"""
type Schedule {
  "Defines the day(s) of the week on which episodes of the show are scheduled."
  byDay: [ByDay]
  "Defines the month(s) of the year on which episodes of the show are scheduled."
  byMonth: [ByMonth]
  """
  Defines the day(s) of the month on which episodes of the show are scheduled. 
              |Specified as an integer between 1-31.
  """
  byMonthDay: [Int]
  """
  Defines the week(s) of the month on which episodes of the show are scheduled. 
              |Specified as an integer between 1-5. For clarity, 
              |byMonthWeek is best used in conjunction with byDay to indicate concepts like 
              |the first and third Mondays of a month.
  """
  byMonthWeek: [Int]
  "The duration of a single episode in the show in milliseconds."
  duration: BigInteger
  "The start date and time of the last episode of the show in ISO 8601 format `YYYY-MM-DDThh:mm:ss.sss[Z|±hh:mm]`."
  end: String
  firstShowing: Boolean
  "Defines the frequency at which episodes will occur according to a schedule. The intervals between episodes should be defined as a duration of time"
  repeatFrequency: ScheduleRepeatFrequency
  "The start date of an episode of the show in ISO 8601 calendar date format `YYYY-MM-DD`."
  startDate: String
  "The start time of an episode of the show in ISO 8601 time format `hh:mm:ss.sss[Z|±hh:mm]`."
  startTime: String
}

"""
Defines the frequency at which episodes will occur according to a schedule. 
        |The intervals between episodes should be defined as a duration of time.".
"""
type ScheduleRepeatFrequency {
  days: Int
  minutes: Int
  months: Int
  weeks: Int
}

"""
A show is a broadcasting container to which a specific episode belongs and
which is used to group individual broadcasts. An example of a show is
"10 vor 10" or "Echo der Zeit".
"""
type Show {
  "In the context of the PDP, this field is used to indicate whether the data may be published publicly."
  confidentialityLevel: ConfidentialityLevel!
  "The detailed descriptions of the show in potentially different languages."
  description: [Text]
  "The PDP id of the show."
  id: String!
  "The brief descriptions of the show in potentially different languages."
  lead: [Text]
  "The source system publishing the metadata."
  provenance: Provenance!
  "Defines the schedules describing the regularly occurring planned publications."
  publications: [Publication]
  "The business unit or external organisation publishing the metadata."
  publisher: Publisher!
  "The id of the show in the source system. It is unique in the source system, but not globally."
  sourceId: String!
  "The titles for the show in potentially different languages."
  title: [Text]
  "Website URL associated with the show."
  websiteUrl: URL
}

"A page containing shows matching the query filters."
type ShowPage {
  cursor: String
  edges: [Show]!
}

type SourceData {
  "Serialized source data (e.g. a JSON object as string)."
  data: String!
  "Mime type of the data (e.g. 'application/json')."
  mimeType: String!
  "Source schema information."
  schema: SourceSchema
}

type SourceSchema {
  "Schema version of the data. Should be changed in case of major schema changes."
  version: String!
}

"A team is a group of clearly identifiable and organizationally related actors who are jointly involved in the creation process of an editorial object. An example of a team is the editorial team of \"Regionaljournal Ostschweiz\"."
type Team implements Agent {
  "The name of the team."
  name: String!
}

"Represents a human readable text for a corresponding asset."
type Text {
  "The content of the text."
  content: String!
}

"A Uniform Resource Locator referencing a resource."
type URL {
  "The URL."
  url: String!
}

"Specifies the fields that can be used to sort articles."
enum ArticleSortField {
  modifiedAt
  releasedAt
  updatedAt
}

"A day of the week."
enum ByDay {
  Friday
  Monday
  Saturday
  Sunday
  Thursday
  Tuesday
  Unknown
  Wednesday
}

"A month of the year."
enum ByMonth {
  April
  August
  December
  February
  January
  July
  June
  March
  May
  November
  October
  September
  Unknown
}

enum ConfidentialityLevel {
  C1_Public
  C2_Internal
  Unknown
}

enum DistributionVector {
  Online
  Radio
  TV
  Unknown
}

"The type of the content."
enum DomainType {
  "An editorial work consisting of text, graphic, sometimes video or audio, created for publication on web-sites, blogs and other channels similar to the more traditional paper-based publications."
  Article
  Channel
  Correlation
  "An editorial work as a stand-alone piece or an episode of a series, intended to be consumed as a whole."
  Programme
}

"The source system publishing the metadata."
enum Provenance {
  AIS_SRF
  CMS_SRF
  CMS_SWI
  Escenic_RSI
  Escenic_RTS
  OfferPortfolio_SRF
  Play_SRF
  Unknown
}

"The publication state of an article."
enum PublicationStatus {
  Published
  Unknown
  Unpublished
}

"""
The business unit or external organisation publishing the metadata.
Please contact the PDP team if a publisher is missing.
"""
enum Publisher {
  AP
  NZZ
  PZBundeshaus
  RSI
  RTR
  RTS
  SRF
  SWI
  SwissTXT
  Unknown
}

"Values for sorting."
enum SortOrder {
  "Sort ascending, nulls first."
  ASC
  "Sort descending, nulls last."
  DESC
}

"The supported languages for a full text search."
enum TextSearchLanguage {
  da
  de
  en
  es
  fi
  fr
  hu
  it
  nb
  nl
  none
  pt
  ro
  ru
  sv
  tr
}

"Scalar for BigDecimal"
scalar BigDecimal

"Scalar for BigInteger"
scalar BigInteger

"Scalar for DateTime"
scalar DateTime

"The returned page will contain only articles that match all filters. Only filters with values affect the result."
input ArticleFilterInput {
  "Filters articles by genre."
  genres: [GenreFilterInput]
  "Filters articles with an id or alternative identifier matching any of the provided identifiers."
  identifiers: [String]
  "Filters articles depending on the value of the field `isLongForm`."
  isLongForm: Boolean
  """
  Filters articles depending on the value of the field `modifiedAt`. If
  the source system did not set a timestamp, then the article will not be included
  if this filter is set.
  """
  modified: TemporalFilterInput
  "Filters articles depending on their provenance."
  provenance: Provenance
  "Filters articles depending on their publisher."
  publisher: Publisher
  """
  Filters articles depending on the value of the field `releasedAt`. If
  the source system did not set a timestamp, then the article will not be included
  if this filter is set.
  """
  released: TemporalFilterInput
  """
  Filters articles depending on when they were updated. An article counts as
  updated when either the source system changes its data or a relation to another
  asset is updated. Updates to related assets like episodes or clips are not taken
  into account.
  """
  updated: TemporalFilterInput
}

"""
The returned list will contain only article genres matching all filters.
Only filters with values affect the result.
"""
input ArticleGenreFilterInput {
  "Filters article genres depending on their provenance."
  provenance: Provenance
  "Filters article genres depending on their publisher."
  publisher: Publisher
}

"Defines a field and order to be used for sorting the articles."
input ArticleSortInput {
  "The field of the article you want to sort by."
  field: ArticleSortField!
  "The order in which want the articles sorted."
  order: SortOrder!
}

"The returned page will contain only channels that match all filters. Only filters with values affect the result."
input ChannelFilterInput {
  "Filters channels matching any of the provided identifiers."
  identifiers: [String]
  "Filters channels depending on their provenance."
  provenance: Provenance
  "Filters channels depending on their publisher."
  publisher: Publisher
  """
  Filters channels depending on when they were updated. A channel counts as
  updated when either the source system changes its data or a relation to another
  asset is updated.
  """
  updated: TemporalFilterInput
}

"The returned page will contain only contents that match all filters. Only filters with values affect the result."
input ContentFilterInput {
  "Filters contents depending on their domain type."
  domainType: DomainType
  "Filters contents with an id or alternative identifier matching any of the provided identifiers."
  identifiers: [String]
  "Filters contents depending on their provenance."
  provenance: Provenance
  "Filters contents depending on their publisher."
  publisher: Publisher
  """
  Filters contents depending on when they were updated. An content counts as
  updated when either the source system changes its data or a relation to another
  asset is updated. Updates to related assets like episodes or clips are not taken
  into account.
  """
  updated: TemporalFilterInput
}

"""
A filter for genres. If you provide a value for this filter, then the 
result will contain any items that contains at least one matching genre.
"""
input GenreFilterInput {
  "Filters items by genre name."
  name: TextFilterInput
}

input ShowFilterInput {
  "Filters shows that have an id or alternative identifier that match any of the provided identifiers."
  identifiers: [String]
  "Filters shows depending on their provenance."
  provenance: Provenance
  "Filters shows depending on their publisher."
  publisher: Publisher
  """
  Filters shows depending on when they were updated. A show counts as
  updated when either the source system changes its data or a relation to another
  asset is modified. Updates to related assets like the show schedule's channel
  are not taken into account.
  """
  updated: TemporalFilterInput
}

"""
A filter for a temporal field. If you provide a date-time for both the after and
before fields, the result will only contain items between those two date-times.
If you only provide one of the date-times, then the result  will contain all
items before or after the respective date-time. Both the after and the before 
date-time are exclusive, i.e. the result will not contain items with the exact 
same date-time.
"""
input TemporalFilterInput {
  """
  Provide an ISO-8601 date-time with an offset from UTC/Greenwich, such as 
  2022-07-18T10:15:30+02:00 to filter for items strictly after that date-time. (ISO-8601)
  """
  after: DateTime
  """
  Provide an ISO-8601 date-time with an offset from UTC/Greenwich, such as 
  2022-07-18T10:15:30+02:00 to filter for items strictly before that date-time. (ISO-8601)
  """
  before: DateTime
}

"A filter for a text field."
input TextFilterInput {
  "Filters texts by content. The result will only contain texts matching the entire content exactly."
  content: String
}
